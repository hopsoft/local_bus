# Generated from lib/local_bus/station.rb with RBS::Inline

class LocalBus
  # An in-process message queuing system that buffers messages before publishing them via Bus.
  #
  # NOTE: Station shares the same publishing interface as Bus
  # IMPORTANT: Be sure to release resources like database connections in subscribers when publishing via Station.
  class Station
    include MonitorMixin

    class QueueFullError < StandardError
    end

    # Constructor
    #
    # @note Delays process exit in an attempt to flush the queue to avoid dropping messages.
    #       Exit flushing makes a "best effort" to process all messages, but it's not guaranteed.
    #       Will not delay process exit when the queue is empty.
    #
    # @rbs bus: Bus -- local message bus (default: Bus.new)
    # @rbs interval: Float -- queue polling interval in seconds (default: 0.01)
    # @rbs size: Integer -- max queue size (default: 10_000)
    # @rbs threads: Integer -- number of threads to use (default: Etc.nprocessors)
    # @rbs timeout: Float -- seconds to wait for subscribers to process the message before cancelling (default: 60)
    # @rbs flush_delay: Float -- seconds to wait for the queue to flush at process exit (default: 1)
    # @rbs return: void
    def initialize: (?bus: Bus, ?interval: Float, ?size: Integer, ?threads: Integer, ?timeout: Float, ?flush_delay: Float) -> void

    # Bus instance
    # @rbs return: Bus
    attr_reader bus: untyped

    # Queue polling interval in seconds
    # @rbs return: Float
    attr_reader interval: untyped

    # Max queue size
    # @rbs return: Integer
    attr_reader size: untyped

    # Number of threads to use
    # @rbs return: Integer
    attr_reader threads: untyped

    # Default timeout for message processing (in seconds)
    # @rbs return: Float
    attr_reader timeout: untyped

    # Starts the station
    # @rbs interval: Float -- queue polling interval in seconds (default: 0.01)
    # @rbs threads: Integer -- number of threads to use (default: self.threads)
    # @rbs return: void
    def start: (?interval: Float, ?threads: Integer) -> void

    # Stops the station
    # @rbs timeout: Float -- seconds to wait for message processing before killing the thread pool (default: nil)
    # @rbs return: void
    def stop: (?timeout: Float) -> void

    def stopping?: () -> untyped

    # Indicates if the station is running
    # @rbs return: bool
    def running?: () -> bool

    # The number of pending unprocessed messages
    # @rbs return: Integer
    def pending: () -> Integer

    # Subscribe to a topic
    # @rbs topic: String -- topic name
    # @rbs callable: (Message) -> untyped -- callable that will process messages published to the topic
    # @rbs &block: (Message) -> untyped -- alternative way to provide a callable
    # @rbs return: self
    def subscribe: (String topic, ?callable: Message) { (Message) -> untyped } -> self

    # Unsubscribe from a topic
    # @rbs topic: String -- topic name
    # @rbs return: self
    def unsubscribe: (String topic) -> self

    # Unsubscribes all subscribers from a topic and removes the topic
    # @rbs topic: String -- topic name
    # @rbs return: self
    def unsubscribe_all: (String topic) -> self

    # Publishes a message to the queue
    #
    # @rbs topic: String | Symbol -- topic name
    # @rbs priority: Integer -- priority of the message, higher number == higher priority (default: 1)
    # @rbs timeout: Float -- seconds to wait before cancelling
    # @rbs payload: Hash[Symbol, untyped] -- message payload
    # @rbs return: Message
    def publish: (String | Symbol topic, ?priority: Integer, ?timeout: Float, **untyped payload) -> Message

    # Publishes a message to the queue
    # @rbs message: Message -- message to publish
    # @rbs return: Message
    def publish_message: (Message message, ?priority: untyped) -> Message
  end
end
